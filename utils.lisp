(in-package #:%rtg-math)

(defmacro case= (form &body cases)
  (let ((g (gensym "val")))
    (labels ((wrap-case (c) `((= ,g ,(first c)) ,@(rest c))))
      (let* ((cases-but1 (mapcar #'wrap-case (butlast cases)))
             (last-case (car (last cases)))
             (last-case (if (eq (car last-case) 'otherwise)
                            `(t ,@(rest last-case))
                            (wrap-case last-case)))
             (cases (append cases-but1 (list last-case))))
        `(let ((,g ,form))
           (cond ,@cases))))))


(defmacro defun-typed (name typed-args -> result-type &body body)
  (assert (string= (symbol-name ->) "->"))
  `(progn
     (declaim (ftype (function ,(mapcar #'second typed-args)
                               ,result-type)
                     ,name))
     (defun ,name ,(mapcar #'first typed-args)
       (declare ,@(mapcar #'reverse typed-args))
       ,@body)))

(defmacro defun-typed-inline (name typed-args -> result-type &body body)
  (assert (string= (symbol-name ->) "->"))
  `(progn
     (declaim (inline make)
              (ftype (function ,(mapcar #'second typed-args)
                               ,result-type)
                     ,name))
     (defun ,name ,(mapcar #'first typed-args)
       (declare ,@(mapcar #'reverse typed-args))
       ,@body)))
